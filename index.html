<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Testing</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
</head>

<body>
    <canvas width="1000" height="600" id="cv"></canvas>

    <script>
        let marketInfo = [] //Holds all the information about the active markets

        $(document).ready(() => {
            const dpcount = new URLSearchParams(window.location.search).get('dpcount') ?? 1440
            
            let cv = document.getElementById("cv")
            
            $.getJSON(`users/1`, (userData) => {
                //Get the info for each portfolio item
                //TODO: no duplicate market requests
                userData.data.forEach(pItem => {
                    let existingMInfo = marketInfo.find(e => e.MarketAbbr === pItem.MarketAbbr)
                    if (existingMInfo) {
                        //If it's already in out info, we dont need to request again
                        HandlePortfolioItem(pItem, existingMInfo, false)
                    } else {
                        $.getJSON(`markets/crypto/${pItem.MarketAbbr}?dpcount=${dpcount}`, (marketData) => {                
                            HandlePortfolioItem(pItem, marketData, true)
                            if (!marketInfo.some(e => e.MarketAbbr === pItem.MarketAbbr))
                                marketInfo.push(marketData)
                        })
                    }
                });
            })
        })

        function HandlePortfolioItem(pItem, marketData, shouldGraph) {
            let currentValue = marketData.data[marketData.data.length - 1].Value * pItem.Amount;
            console.log(`Current ${pItem.MarketAbbr} val: ${currentValue}`,
                `Change: ${currentValue - pItem.BuyPrice} | ${(currentValue / pItem.BuyPrice - 1) * 100}%`)
            
            if (shouldGraph)
                GraphMarket(marketData, cv, "#FF00FF")
        }

        //Graphs a market based on the market data, a reference to the canvas on which is is to be drawn and the color
        function GraphMarket(marketData, cv, color) {
            let ctx = cv.getContext('2d')
            ctx.strokeStyle = color

            let min = Math.min(...marketData.data.map(o => o.Value))
            let max = Math.max(...marketData.data.map(o => o.Value))

            let p = ScalePoint(
                { x: 0, y: marketData.data[0].Value },
                { width: cv.width, height: cv.height },
                { len: marketData.data.length, min: min, max: max })
            ctx.beginPath()

            ctx.moveTo(p.x, p.y)
            for (let i = 1; i < marketData.data.length; i++) {
                p = ScalePoint(
                    { x: i, y: marketData.data[i].Value },
                    { width: cv.width, height: cv.height },
                    { len: marketData.data.length, min: min, max: max })
                ctx.lineTo(p.x, p.y)
            }
            ctx.stroke()

        }

        //Scales a point for given canvas dimensions and data dimensions.
        function ScalePoint(p, cDims, dDims) {
            let ret = { x: 0, y: 0 }
            ret.x = p.x / dDims.len * cDims.width
            ret.y = cDims.height - ((p.y - dDims.min) / (dDims.max - dDims.min) * cDims.height)
            return ret
        }
    </script>
</body>

</html>