<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Testing</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
    <style>
        .table-positive .table-color-adjustable {
            color: rgb(120, 189, 17);
        }
        .table-negative .table-color-adjustable {
            color: red;
        }
    </style>
</head>

<body>
    <canvas width="1000" height="600" id="cv"></canvas>

    <table id="change-table">
        <tbody>
            <tr>
                <th>Market</th>
                <th>Amount</th>
                <th>Value</th>
                <th>Change</th>
                <th>Change (%)</th>
            </tr>
        </tbody>
    </table>
    <script>
        let marketInfo = [] //Holds all the information about the active markets

        $(document).ready(() => {
            const dpcount = new URLSearchParams(window.location.search).get('dpcount') ?? 1440
            
            let cv = document.getElementById("cv")
            
            $.getJSON(`users/1`, (userData) => {
                //Get the info for each portfolio item
                //TODO: no duplicate market requests
                userData.data.forEach(pItem => {
                    //Try to find an existing market info in memory
                    let existingMInfo = marketInfo.find(e => e.MarketAbbr === pItem.MarketAbbr)

                    if (existingMInfo) {
                        //If it's already in out info, we dont need to request again
                        HandlePortfolioItem(pItem, existingMInfo, false)
                    } else {
                        //No market info was found, so it needs to be requested
                        $.getJSON(`markets/crypto/${pItem.MarketAbbr}?dpcount=${dpcount}`, (marketData) => {                
                            HandlePortfolioItem(pItem, marketData, true)

                            //Recheck to see if the marketinfo wasnt asynchronously added, if not, add it to the array
                            if (!marketInfo.some(e => e.MarketAbbr === pItem.MarketAbbr))
                                marketInfo.push(marketData)
                        })
                    }
                });
            })
        })

        //Handles a portfolioitem by showing its graph and its profits/losses
        function HandlePortfolioItem(pItem, marketData, shouldGraph) {
            let currentValue = marketData.data[marketData.data.length - 1].Value * pItem.Amount

            $('#change-table > tbody:last-child').append(`
                <tr class=${currentValue > pItem.BuyPrice ? "table-positive" : "table-negative"}>
                    <td>${pItem.MarketAbbr}</td>
                    <td>${pItem.Amount}</td>
                    <td class="table-color-adjustable">${(currentValue).toFixed(2)}</td>
                    <td class="table-color-adjustable">${(currentValue - pItem.BuyPrice).toFixed(2)}</td>
                    <td class="table-color-adjustable">${((currentValue / pItem.BuyPrice - 1) * 100).toFixed(2)}</td>
                </tr>
            `)
            
            if (shouldGraph)
                GraphMarket(marketData, cv, "#FF00FF")
        }

        //Graphs a market based on the market data, a reference to the canvas on which is is to be drawn and the color
        function GraphMarket(marketData, cv, color) {
            let ctx = cv.getContext('2d')
            ctx.strokeStyle = color

            let min = Math.min(...marketData.data.map(o => o.Value))
            let max = Math.max(...marketData.data.map(o => o.Value))

            let p = ScalePoint(
                { x: 0, y: marketData.data[0].Value },
                { width: cv.width, height: cv.height },
                { len: marketData.data.length, min: min, max: max })
            ctx.beginPath()

            ctx.moveTo(p.x, p.y)
            for (let i = 1; i < marketData.data.length; i++) {
                p = ScalePoint(
                    { x: i, y: marketData.data[i].Value },
                    { width: cv.width, height: cv.height },
                    { len: marketData.data.length, min: min, max: max })
                ctx.lineTo(p.x, p.y)
            }
            ctx.stroke()

        }

        //Scales a point for given canvas dimensions and data dimensions.
        function ScalePoint(p, cDims, dDims) {
            let ret = { x: 0, y: 0 }
            ret.x = p.x / dDims.len * cDims.width
            ret.y = cDims.height - ((p.y - dDims.min) / (dDims.max - dDims.min) * cDims.height)
            return ret
        }
    </script>
</body>

</html>